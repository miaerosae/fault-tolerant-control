import numpy as np
import math

import fym
from fym.core import BaseEnv, BaseSystem
from fym.utils.rot import dcm2quat, quat2dcm, angle2quat, quat2angle, angle2dcm
from ftc.agents.param import get_uncertainties

import ftc.config


cfg = ftc.config.load(__name__)


class Mixer:
    """Definition:
        Mixer takes force commands and translate them to actuator commands.
        Actuator commands here mean the force generated by each rotor.
    """
    def __init__(self, d, c, b):
        rtype = cfg.mixer.rtype

        if rtype == "quad":
            B = np.array(
                [[b, b, b, b],
                 [0, -b*d, 0, b*d],
                 [b*d, 0, -b*d, 0],
                 [-c, c, -c, c]]
            )

        elif rtype == "hexa-x":
            b = 1
            B = np.array(
                [[b, b, b, b, b, b],
                 [-b*d, b*d, b*d/2, -b*d/2, -b*d/2, b*d/2],
                 [0, 0, b*d*np.sqrt(3)/2, -b*d*np.sqrt(3)/2, b*d*np.sqrt(3)/2,
                  -b*d*np.sqrt(3)/2],
                 [-c, c, -c, c, c, -c]]
            )

        elif rtype == "hexa-+":
            b = 1
            B = np.array(
                [[b, b, b, b, b, b],
                 [0, 0, b*d*np.sqrt(3)/2, -b*d*np.sqrt(3)/2, b*d*np.sqrt(3)/2,
                  -b*d*np.sqrt(3)/2],
                 [-b*d, b*d, b*d/2, -b*d/2, -b*d/2, b*d/2],
                 [-c, c, -c, c, c, -c]]
            )
            self.b_gyro = np.vstack((1, -1, 1, -1, 1, -1))

            s2 = 1/2
            s3 = np.sqrt(3)/2
            self.d_rotor = np.array([
                [d, 0, 0],
                [d*s2, -d*s3, 0],
                [-d*s2, -d*s3, 0],
                [-d, 0, 0],
                [-d*s2, d*s3, 0],
                [d*s2, d*s3, 0],
            ])

        elif rtype == "hexa-falconi":
            B = np.array(
                [[b, b, b, b, b, b],
                 [0.5*d*b, d*b, 0.5*d*b, -0.5*d*b, -d*b, -0.5*d*b],
                 [0.5*np.sqrt(3)*d*b, 0, -0.5*np.sqrt(3)*d*b,
                  -0.5*np.sqrt(3)*d*b, 0, 0.5*np.sqrt(3)*d*b],
                 [c, -c, c, -c, c, -c]]
            )

        else:
            B = np.eye(4)

        self.b = b
        self.B = B
        self.Binv = np.linalg.pinv(B)

    def inverse(self, rotors):
        return self.B.dot(rotors)

    def __call__(self, forces):
        return self.Binv.dot(forces)


class Multicopter(BaseEnv):
    """Multicopter Model
    Variables:
        pos: position in I-coord
        vel: velocity in I-coord
        quat: unit quaternion.
            Corresponding to the rotation matrix from I- to B-coord.

    Drag model [1]:
        self.M_gyroscopic
        self.A_drag
        self.B_drag
        self.D_drag
        - Note: orientation `R` in the paper is `dcm.T`

    References:
        [1] M. Faessler, A. Franchi, and D. Scaramuzza, “Differential Flatness of Quadrotor Dynamics Subject to Rotor Drag for Accurate Tracking of High-Speed Trajectories,” IEEE Robot. Autom. Lett., vol. 3, no. 2, pp. 620–626, Apr. 2018, doi: 10.1109/LRA.2017.2776353.
    """
    def __init__(self, pos, vel, quat, omega, blade, ext_unc, int_unc,
                 hub, gyro, uncertainty, ground, drygen, dx=0.0, dy=0.0, dz=0.0, ):
        super().__init__()
        self.pos = BaseSystem(pos)
        self.vel = BaseSystem(vel)
        self.quat = BaseSystem(quat)
        self.omega = BaseSystem(omega)

        fym.parser.update(cfg.physProp,
                          fym.parser.decode(cfg.physPropBy)[cfg.modelFrom])
        for k, v in fym.parser.decode(cfg.physProp).items():
            self.__setattr__(k, v)

        self.M_gyroscopic = np.zeros((3, 1))
        self.A_drag = np.diag(np.zeros(3))  # currently ignored
        self.B_drag = np.diag(np.zeros(3))  # currently ignored
        self.D_drag = np.diag([dx, dy, dz])
        if uncertainty is True:
            c = cfg.model_uncert.del_c * self.c
            b = cfg.model_uncert.del_b * self.b
        else:
            c, b = self.c, self.b
        self.mixer = Mixer(d=self.d, c=c, b=b)

        self.blade = blade
        self.ext_unc = ext_unc
        self.int_unc = int_unc
        self.hub = hub
        self.gyro = gyro
        self.uncertainty = uncertainty
        self.ground = ground
        self.drygen = drygen

    def deriv(self, t, pos, vel, quat, omega, rotors, windvel, prev_rotors):
        if self.blade is False:
            F, M1, M2, M3 = self.mixer.inverse(rotors)
            M = np.vstack((M1, M2, M3))
        else:
            F, M = self.get_FM_wind(rotors, vel, omega, windvel)

        if self.ground is True:
            F = self.groundEffect(F)

        m, g, J = self.m, self.g, self.J
        if self.uncertainty is True:
            m = cfg.model_uncert.del_m * m
            J = cfg.model_uncert.del_J * J
        Jinv = np.linalg.inv(J)
        e3 = np.vstack((0, 0, 1))

        # uncertainty
        ext_pos, ext_vel, ext_euler, ext_omega = get_uncertainties(t, self.ext_unc)
        int_pos, int_vel, int_euler, int_omega = self.get_int_uncertainties(t, vel)
        gyro = self.get_gyro(omega, rotors, prev_rotors)
        drygen = self.get_drygen(t, pos[2], vel, quat)

        # wind: vel = vel - windvel
        dpos = vel + ext_pos + int_pos
        dcm = quat2dcm(quat)
        dvel = (g*e3 - F*dcm.T.dot(e3)/m
                - dcm.T.dot(self.D_drag).dot(dcm).dot(vel)
                + ext_vel + int_vel + drygen/m
                )
        # wind: 바람 추가
        # DCM integration (Note: dcm; I to B) [1]
        p, q, r = np.ravel(omega)
        # unit quaternion integration [4]
        dquat = 0.5 * np.array([[0., -p, -q, -r],
                                [p, 0., r, -q],
                                [q, -r, 0., p],
                                [r, q, -p, 0.]]).dot(quat)
        eps = 1 - (quat[0]**2+quat[1]**2+quat[2]**2+quat[3]**2)
        k = 1
        dquat = (dquat + k*eps*quat
                 + angle2quat(ext_euler[2]+int_euler[2],
                              ext_euler[1]+int_euler[1],
                              ext_euler[0]+int_euler[0]))
        domega = Jinv.dot(
            M
            - np.cross(omega, J.dot(omega), axis=0)
            + gyro
            - self.M_gyroscopic
            - self.A_drag.dot(dcm).dot(vel)
            - self.B_drag.dot(omega)
            + windvel
        ) \
            + ext_omega + int_omega

        return dpos, dvel, dquat, domega

    def get_model_uncertainty(self, rotors):
        # calculate real and disturbance value of F, M
        F_dist, M1, M2, M3 = self.mixer.inverse(rotors)
        delc = cfg.model_uncert.del_c
        delb = cfg.model_uncert.del_b

        F_real = 1 / delb * F_dist
        M1_real = 1 / delb * M1
        M2_real = 1 / delb * M2
        M3_real = 1 / delc * M3

        M_real = np.vstack((M1_real, M2_real, M3_real))
        M_dist = np.vstack((M1, M2, M3))

        e3 = np.vstack((0, 0, 1))
        dcm = quat2dcm(self.quat.state)
        omega = self.omega.state
        Jinv_real = np.linalg.inv(self.J)
        vel_real = (- F_real*dcm.T.dot(e3)/self.m)
        omega_real = Jinv_real.dot(M_real - np.cross(omega, self.J.dot(omega), axis=0))

        delm = cfg.model_uncert.del_m
        delJ = cfg.model_uncert.del_J
        Jinv_dist = np.linalg.inv(self.J*delJ)
        vel_dist = (- F_dist*dcm.T.dot(e3)/(self.m*delm))
        omega_dist = Jinv_dist.dot(M_dist - np.cross(omega, (self.J*delJ).dot(omega), axis=0))

        return vel_dist-vel_real, omega_dist-omega_real

    def set_dot(self, t, rotors, windvel=np.zeros((3, 1)),
                prev_rotors=np.zeros((4, 1))):
        states = self.observe_list()
        dots = self.deriv(t, *states, rotors, windvel, prev_rotors)
        self.pos.dot, self.vel.dot, self.quat.dot, self.omega.dot = dots

    def get_int_uncertainties(self, t, vel):
        if self.int_unc is True:
            int_pos = np.zeros((3, 1))
            # int_vel = np.vstack([
            #     vel[0]*vel[1] + (1+np.sin(vel[0]))*vel[1] + 2*vel[0] + 2 + np.sin(t),
            #     -vel[0]*vel[2] + (1+np.sin(vel[1]))*vel[2] + 2*vel[1] + np.cos(2*t),
            #     vel[2] + np.exp(-t)*np.sin(t+np.pi/4)
            # ])
            int_vel = np.vstack([
                np.sin(vel[0])*vel[1],
                np.sin(vel[1])*vel[2],
                np.exp(-t)*np.sin(t+np.pi/4)
            ])
            int_euler = np.zeros((3, 1))
            int_omega = np.zeros((3, 1))
        else:
            int_pos = np.zeros((3, 1))
            int_vel = np.zeros((3, 1))
            int_euler = np.zeros((3, 1))
            int_omega = np.zeros((3, 1))
        return int_pos, int_vel, int_euler, int_omega

    def get_gyro(self, omega, rotors, prev_rotors):
        # propeller gyro effect
        if self.gyro is True:
            p, q, r = omega.ravel()
            Omega = rotors ** (1/2)
            Omega_r = - Omega[0] + Omega[1] - Omega[2] + Omega[3]
            prev_Omega = prev_rotors ** (1/2)
            prev_Omega_r = (- prev_Omega[0] + prev_Omega[1]
                            - prev_Omega[2] + prev_Omega[3])
            gyro = np.vstack([self.Jr * q * Omega_r,
                              - self.Jr * p * Omega_r,
                              self.Jr * (Omega_r - prev_Omega_r)])
        else:
            gyro = np.zeros((3, 1))
        return gyro

    def groundEffect(self, u1):
        h = - self.pos.state[2]

        if h == 0:
            ratio = 2
        else:
            ratio = 1 / (1 - (self.R/4/self.pos.state[2])**2)

        if ratio > self.max_IGE_ratio:
            u1_d = self.max_IGE_ratio * u1
        else:
            u1_d = ratio * u1
        return u1_d

    def get_drygen(self, t, z, vel, quat):
        if self.drygen is True:
            var = cfg.physProp
            rho = self.get_rho(-z)
            R_bar = abs(angle2dcm(quat2angle(quat)))
            A = R_bar.dot(np.vstack([var.Au, var.Av, var.Aw]))
            A = A.ravel()
            Cd = np.vstack([var.Cdx, var.Cdy, var.Cdz])
            v_w = self.get_v_w_bar(t) + self.get_v_w_hat()

            d = - 1 / 2 * rho * Cd * A * (vel-v_w)**2 * np.sign(vel-v_w)
            return d[:, None]
        else:
            return np.zeros((3, 1))

    def get_v_w_bar(self, t):
        var = cfg.wind_dist
        v1 = np.array([var.vx1, var.vy1, var.vz1])
        v2 = np.array([var.vx2, var.vy2, var.vz2])
        if t < var.t1:
            v_w_bar = v1
        elif t < var.t2:
            v_w_bar = (v2+v1)/2 - (v2-v1)/2*np.cos(np.pi*(t-var.t1)/(var.t2-var.t1))
        else:
            v_w_bar = v2
        return v_w_bar

    def get_v_w_hat(self, z):
        sig_w = 0.1 * cfg.wind_dist.W20
        sig_u = sig_w / (0.177 + 0.000823*(-z))**0.4
        sig_v = sig_u
        Lw = - z
        Lu = - z / (0.177 + 0.000823*(-z))**1.2
        Lv = Lu
        return v_w_hat

    def get_rho(self, altitude):
        pressure = 101325 * (1 - 2.25569e-5 * altitude)**5.25616
        temperature = 288.14 - 0.00649 * altitude
        return pressure / (287*temperature)

    # def get_d(self, W, rotors):
    #     rotor_n = rotors.shape[0]
    #     fault = W - np.eye(rotor_n)
    #     return self.mixer.B.dot(fault.dot(rotors))

    # def get_Omega(self, f):
    #     f = np.clip(f, 0, self.rotor_max)
    #     Omega = self.mixer.b_gyro.T.dot(np.sqrt(f / self.mixer.b))
    #     return Omega

    # def get_FM_wind(self, f, vel, omega, windvel):
    #     relvel = windvel - vel

    #     f = np.clip(f, 0, self.rotor_max)

    #     # Frame drag
    #     F_drag = 1/2 * self.rho * self.CdA * np.linalg.norm(relvel) * relvel

    #     # Blade Flapping
    #     F_blade = np.zeros((3, 1))
    #     M_blade = np.zeros((3, 1))
    #     for fi, di in zip(f, self.mixer.d_rotor):
    #         di = di[:, None]
    #         if fi != 0:
    #             Omegai = np.sqrt(fi / self.mixer.b)
    #             vr = relvel + np.cross(omega, di, axis=0)
    #             mur = np.linalg.norm(vr[:2]) / (Omegai * self.R)
    #             psir = np.arctan2(vr[1, 0], vr[0, 0])
    #             lambdah = np.sqrt(self.CT / 2)
    #             gamma = self.rho * self.a0 * self.ch * self.R**4 / self.Jr
    #             v1s = 1 / (1 + mur**2 / 2) * 4 / 3 * (
    #                 self.CT / self.sigma * 2 / 3 * mur * gamma / self.a0 + mur)
    #             u1s = 1 / (1 - mur**2 / 2) * mur * (
    #                 4 * self.thetat - 2 * lambdah**2)
    #             alpha1s, beta1s = np.array([
    #                 [np.cos(psir), -np.sin(psir)],
    #                 [np.sin(psir), np.cos(psir)]
    #             ]).dot(np.vstack((u1s, v1s)))

    #             ab = np.vstack((
    #                 -np.sin(alpha1s),
    #                 -np.cos(alpha1s) * np.sin(beta1s),
    #                 np.cos(alpha1s) * np.cos(beta1s) - 1))

    #             F_blade += self.mixer.b * Omegai**2 * ab
    #             M_blade += np.cross(di, self.mixer.b * Omegai**2 * ab, axis=0)

    #     F_wind = F_blade + F_drag
    #     M_wind = M_blade

    #     return F_wind, M_wind


if __name__ == "__main__":
    system = Multicopter()
    system.set_dot(t=0, rotors=np.zeros((6, 1)))
    print(repr(system))
